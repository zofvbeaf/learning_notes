### 编译过程

+ 预编译：宏展开，拷贝`#include`的文件，删除注释

  ```bash
  # 预编译
  cpp hello.c > hello.i     # 或
  gcc -E hello.c -o hello.i 
  ```

+ 编译：词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件，中间会生成中间代码，以界定前端和后端

  ```bash
  cc1 hello.c # 或
  gcc -S hello.c -o hello.s 
```
  
+ 汇编：将汇编代码转变成机器可以执行的指令

  ```bash
  as hello.s -o hello.o # 或
  gcc -c hello.s -o hello.o
  ```

+ 链接：调用`ld`

### 目标文件的格式

+ `file`命令可以看文件类型信息

+ `ELF`文件类型：

  + 可重定位文件：`.o`
  + 可执行文件
  + 共享目标文件：`.so`
  + 核心转储文件：`core`

+ `readelf -h test`可以查看`ELF`文件头，`ELF header`中包含了

  + 一个段表，描述了文件中各个段的偏移和属性
  + 程序入口地址
  + 文件机器字节长度，大端小端，运行平台

+ `man elf`或者`man core`可以查看相应文件类型信息

+ 目标文件的布局

  + 未初始化的**全局变量**和未初始化的**局部静态变量**在`.bss`段，因为默认值为`0`（自己设定初始值为`0`也一样），没必要分配空间，`.bss`段是为所有这些变量需要的空间预留位置，它并没有内容，在文件中只占`4`字节，记录这些位置大小总和

    + 通过符号表可以看到每个符号对应段，`objdump -x test`

  + 一般在`data`段

  + 另外还有只读数据段(`.rodata`)，注释信息段(`.comment`)，堆栈提示段(`.note.GNU-stack`)

    + `const`修饰的变量在`.rodata`段

  + 重定位表：也称重定位段，在目标文件中通常有多个，`.text`段对应的重定位段为`.rel.text`，`.data`段对应的重定位段为`.rel.data`

  + 其他段

    ![](https://ws1.sinaimg.cn/large/77451733gy1g60dfjxbdpj20lv0dagp4.jpg)

+ 分区的优点

  + 方便权限管理，比如代码段只读，数据段可读可写
  + 有利于提高程序的局部性，提升缓存命中率
  + 多个进程可以共享一份代码段

+ `objdump -h test`可以看`ELF`各个段的信息

+ 特殊符号

  + `__executable_start`，程序起始地址，不是入口地址，是程序最开始的地址
  + `__etext`，代码段结束地址，即代码段最末尾的地址
  + `__edata`，数据段结束地址
  + `__end`，程序结束地址
  + 以上都为被装载时的虚拟地址

+ `c++`函数签名

  ```c++
  #ifdef __cplusplus  // 以防是c文件, 无 extern "C" 的语法
  extern "C" {
  #endif
  
  void * memset(void *, int, size_t);
  
  #ifdef __cplusplus
  }
  #endif
  ```

+ 强符号与弱符号

  + 默认情况下，函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。通过`gcc`的`__attribute__((weak))`可以定义任何一个强符号为弱符号

    ```c++
    extern int ext;     //外部变量的引用，即非强符号也非弱符号
    
    int weak;       //弱符号
    int strong = 1; //强符号
    __attribute__((weak)) int weak2 = 2;    //弱符号
    
    int main()      //强符号
    {
        return 0;
    }
    ```

  + 链接器按以下规则处理多次定义的全局符号

    + 不允许强符号被多次定义（不同目标文件中不能有同名的强符号），否则，报重定义错误
    + 若符号在某个文件中是强符号，在其他文件中都是弱符号，则选择强符号
    + 若符号在所有文件中都是弱符号，则选择占用空间最大的那个。如：
      + 文件A：`int s;`
      + 文件B：`double s;`
      + 则链接后`s`占用`8`个字节大小。这一问题容易导致很隐秘的错误

+ 强引用与弱引用

  + 针对外部文件的符号引用，在目标文件被链接成可执行文件时，需要被正确决议

    + 强引用：若在决议时没有找到符号的定义，链接器会报符号未定义错误
    + 弱引用：在决议该符号时，如果符号未定义，则不报错；如果符号有定义，则决议该符号的引用

  + 一般对于弱引用，链接器将其值默认为0，或者一个特殊的值。

  + 使用`__attribute__((weakref))`来声明一个外部函数的引用为弱引用。要注意的是，弱引用可能并没有被链接到某个函数上去，所以在调用前最好判断一下它的值，如下：

    ```c
    __attribute__((weakref)) void foo();
    
    int main()
    {
        if(foo) foo();
    }
    ```

  + 这种方式对库来说非常有用，库里面的弱引用可以被用户定义的强引用覆盖；程序的某些扩展功能可以被定义为弱引用，这样，将扩展模块和程序链接在一起时，功能模块就可以正常使用了，如果去掉扩展模块，程序也能正常链接。

+ 调试信息

  + 通过`gcc -g`，可以保留许多调试信息。
  + `ELF`文件采用`DWARF`标准来保存调试格式，`VC++`的调试信息格式为`CodeView`。
  + 使用`strip`命令可以去掉`elf`文件的调试信息。

+ 相关命令汇总

  ```bash
  readelf -h test
  man elf          # man core
  objdump -h test  # 类似 readelf -S test 获取 ELF Header 中的段表
  objdump -x test  # 可以打印出更多信息， 所有 headers，所有符号信息
  objdump -s -d test # -s 可以将所有段以16进制打印出来，-d可以将所有包含指令的段反汇编
  size test        # 可以看各个段的长度
  __attribute__((section("FOO"))) void foo() # 在代码中指定函数或变量所属的段
  nm test  # 查看 test 中的所有符号
  c++filt symbol_name  # 查看被修饰前的符号名称
  strip test # 可以去掉 elf 文件的调试信息
  ld a.o b.o -e main -o ab # 链接，指定 main 函数作为入口, ld 链接器的默认入口是 _start
  ar -t libc.a             # 查看静态库中有哪些文件
  ld -verbose              # 查看链接脚本
  readelf -l test          # 读 segment 信息
  cat /proc/12345/maps     # 查看 id 为 12345 的进程的虚拟地址空间布局
  readelf -l lib.so        # 查看动态链接库的装载属性
  ```

### 静态链接

+ 空间与地址分配
  + 链接器在链接时，虚拟地址空间的分配分为两步：
    + 空间与地址分配
    + 符号解析与重定位
  + 第一步只需要将各个目标文件的相似段合并起来，组成更大的段即可
  + 第二步则是进行重定位操作。重定位分为绝对地址重定位和相对地址重定位
    + 绝对地址重定位，如对于某个变量地址的寻址，该地址就是绝对地址
    + 相对地址重定位，如跳转到某个地址，如果使用“近址相对位移调用指令”，那么这条指令的地址就是个相对地址。
+ `c++`相关的问题
  + 重复代码消除
    + 多个编译单元用模板、外部内联函数、虚函数表生成了相同的代码时，链接器需要保持一份这样的代码即可。否则：
      + 空间浪费，比如模版的多个实例化
      + 地址较易出错，两个指向同一函数的指针可能不相等
      + `cache`命中率下降
    + 解决方法是将每个模板的实例代码都单独放在一个段里，每个段只包含一个模板实例，在最终链接时可以直接区分相同的段（相同模版相同参数会生成相同的名字），以合并入最终段。
    + `GCC`将这些段命名为`.gnu.linkonce.name`，`name`为模板函数实例的修饰后名称。`VC++`将这些类型的段叫做`COMDAT`。外部内联函数、虚表、默认构造/拷贝函数、赋值操作符等也有类似的问题。
  + 函数级别链接
    + 库里面有很多函数，如果只用到一两个函数，就链接所有函数进来，那么可执行文件会很大。因此有了**函数级别链接**技术。
    + `VC++`的编译选项为（`Functional-Level Linking，/Gy`）。它将每个函数放入一个段，当链接器需要用到哪个函数时，才将这个段合并到输出文件中。但是由于要计算函数的依赖关系，并且所有函数都在不同的段，所以会增加链接和重定位时间。
    + `GCC`提供类似功能，编译选项为`"-ffunction-sections"`和`"-fdata-sections"`。第一个用来将函数放入单独的段，第二个用来将变量放入单独的段。
  + 全局构造与析构
    + `elf`文件定义了两个段：`.init`和`.fini`。分别用来存放进程的初始化和反初始化代码。这些代码在进入`main`函数之前/退出`main`函数之后执行。最具代表性的就是全局对象的构造/析构。
  + 静态库的链接
    + 库编译完后，得到的其实是一个一个的`.o`文件，如`c`库，得到很多如`printf.o、scanf.o、fread.o、fwrite.o`之类的文件，为了组织方便，会使用压缩程序ar将其压缩起来，并建立索引。
    + 用`ar -t libc.a`可以查看里面有什么文件。
    + `VC++`下用`lib.exe`查看。`lib /LIST libcmt.lib`
    + 静态运行库里面，一个`.o`文件里只有一个函数，如`printf.o`只有`printf`函数，`strlen.o`只有`strlen`函数。这样做，可以最大程度上避免链接目标文件时，链接一些无用的代码进来
  + `gcc`的编译过程
    + 使用`gcc -verbose`选项可以看到`gcc`的编译过程。分为三步：
      + 使用`cc1`来将`.c`编译成`.s`汇编文件
      + 使用`as`来将`.s`文件汇编成临时目标文件`.o`
      + 调用`collect2`来进行链接（`collect2`可看作`ld`的包装）
  + 链接控制过程
    + 命令行参数，如`ld -o -e`选项
    + 将链接指令放在目标文件里，编译器经常用这种方法向链接器传递指令。如`VC++`将参数放在`.drectve`段中。
    + 链接控制脚本，使用`-T`选项向链接器指定脚本。
    + `ld -verbose` 查看链接默认脚本

### 可执行文件的装载与进程

+ 装载的方式
  + 覆盖装入：现在已经被淘汰
    + 在上古时代用，假如main模块要调用A和B模块，A和B模块之间相互不调用。那么通过覆盖管理器，可以做到如下效果：main模块常驻内存，在main模块需要调用A模块的时候，将A的模块装入内存，需要B模块的时候，将B模块装入内存。A模块和B模块位于同一段内存区域，通过覆盖装入的方式重用这部分内存。这样，由于不需要同时装入A、B模块，所以节省了内存开销。这是典型的空间换时间。
    + 注意，这个方法并不是这么简单，模块之间的调用关系是一棵树，需要保证
      - 当该某块被调用时，整个调用路径上的模块必须都在内存中，否则不能正确返回到main模块
      - 禁止跨树间调用
  + 页映射
    + 借助`MMU`，将虚拟地址映射到物理地址上去。并不需要所有的虚拟地址都有物理内存映射。
+ 从操作系统角度看可执行文件的装载
  + 进程的建立
    + 进程建立需要做三件事：
      + 创建一个独立的虚拟地址空间
      + 这一步其实是建立虚拟地址空间的数据结构，在`X86`上，分配页目录即可。甚至不需要建立映射关系。
    + 读取可执行文件头，并建立虚拟空间与可执行文件的映射关系
      + 建立映射关系是通过数据结构`VMA`（`linux`的叫法，`Virtual Memory Area`)或者虚拟段（`Windows`的叫法，`Virtual Section`）来实现的。
      + 将`CPU`的指令寄存器设置成可执行文件的入口地址，启动运行。
        + 这一步涉及用户堆栈和内核堆栈的切换，`CPU`运行权限的切换等。
  + 页错误
    + 进程创建后，实际上是没有映射关系的。每当访问一个没有建立映射关系的页面时，会出现`page fault`，这时候`OS`才建立真正的映射关系。
  + 进程虚存空间分布
    + `ELF`文件链接视图和执行视图
      + ELF文件的段的权限通常有三种：
        + 以代码段为代表的可读可执行段
        + 以数据段和BSS段为代表的可读可写段
        + 以只读数据段为代表的只读段
      + 从链接器的角度来看，`ELF`文件分为一个个的段(`Section`)。但是，从装载器的角度来看，`ELF`文件分为一个个的`Segment`（中文也叫段）。
      + 所谓`Segment`，就是将相同权限属性的段尽可能的组织在相邻位置，形成一个一个的`Segment`，便于装载时节省内存。（一个`Section`可能不足一个页大小，按`Section`一个个装载会导致很大的空间浪费）
      + 使用`readelf -S`来看`Section`的分布。使用`readelf -l`来看`Segment`的分布。
    + 在链接器角度来看，`elf`是由`Section`组成的。在装载器的角度看，`elf`是由`Segment`组成的。
    + `Segment`的`p_type`为`LOAD`，则说明可装载。对于`LOAD`类型的段来说，`p_memsz`的值一般不小于`p_filesz`的值。当`p_memsz`大于`p_filesz`时，说明`Segment`在内存中的占用空间大于在文件中的空间，这时将这些多出来的空间全部填`0`，即不需要额外为`ELF`文件设立`BSS`段了。因此，可以在`readelf -l`中发现，只有两个`LOAD`类型的段，而不是三个，因为`BSS`段被合并到数据类型的段中了。
    + 除了这些需要装载的`Segment`外，在运行时还会有堆和栈。`Linux`用`vma`来描述内存区域。
  + 段地址对齐
    + 假如页大小为`4K`，那么`Segment`的大小也应该对齐到`4K`。不过，如果有很多`Segment`，每个`Segment`的大小又很小，强行对齐到`4K`会浪费很多资源。
    + 这种情况下，`linux`使用了一种取巧的技术。将各个段接壤部分的共享一个物理页面，然后将该页面映射两次。
      + 假如段`S1`和`S2`有接壤的部分，段`S1`的最后一页的起始线性地址是`V1`，段`S2`的起始地址是`V2`，那么，系统将找一个物理页面`P`，将`S1`和`S2`的接壤部分都塞到`P`里面。然后，将`V1`映射到`P`，将`V2`也映射到`P`，这两次映射的页面属性可能不同（比如`S1`是可读可写的，`S2`是可执行的，那么`V1`就是可读可写，`V2`就是可执行的）。注意，这个方法会导致`S2`的起始地址不是`4K`对齐的。
  + 进程栈初始化
    + 进程栈在初始化时，`main`函数的上端（高地址部分）是环境变量的信息。
  + `linux`下`elf`的装载过程
    + 通过`execl*()`家族的函数进入系统调用
    + 进入`sys_execv()`，进行参数检查
    + 调用`do_execve()`，找到被执行的文件，然后读前128字节，判断文件类型（脚本语言，`java`程序，`ELF`文件等等）
    + 调用`search_binary_handle()`去搜索和匹配合适的可执行文件装载处理过程（`elf`文件对应的处理过程为`load_elf_binary()`)
      - 检查`ELF`文件格式的有效性，如魔数，程序头表中的段数量
      - 寻找动态链接的`.interp`段，设置动态链接器路径
      - 根据`ELF`文件程序头表的描述，进行映射
      - 初始化`ELF`进程环境，比如进程启动时`EDX`寄存器的地址应该是`DT_FINI`的地址
      - 将系统调用的返回地址修改为`ELF`可执行文件的入口点。入口点由链接方式决定，静态链接的入口点由文件头的`e_entry`指向，动态链接的入口点为动态链接器
    + 逐级往上返回，程序加载完成。

### 动态链接

+ 为什么要动态链接
  + 节省内存空间，也节省磁盘空间，减少编译后的可执行文件大小
  + 便于程序更新（换`DLL`就行，不过要是`API`不兼容，就会出现`DLL Hell`）
+ 共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的对象
+ 地址无关的代码
  + 重定位分类
    + 在静态链接时的重定位称为**链接时重定位**，在装载时的重定位称为**装载时重定位**，也叫**基址重置**。
    + 装载时重定位的概念在没有虚拟存储时就出现了。程序直接装载进物理内存，但是如果此时期望的目标地址已经被占用了，那么只能够加载到其他位置，这是就需要重定位了。
    + 通过`gcc`的`-shared`选项，能够控制输出的目标代码使用装载时重定位的方法，但是这个方法不能够使得共享对象被各个进程共享（因为装载时重定位会去修改代码中的那些绝对地址引用，使它们指向重定位后合适的值）。需要配合`-fPIC`一起使用才行。
  + 地址无关的代码
    + 动态模块如果使用绝对地址引用,那么就无法在各个进程之间共享.`PIC(Position-independent Code)`技术将指令中那些需要被修改的部分分离出来，和数据部分放在一起，这样，指令部分不用变，数据部分每个进程一个副本，就能解决绝对地址引用的问题。
+ 地址引用方式分类以及解决方法：
  + 模块内部调用或跳转
    + 使用相对地址调用指令（jump中记录的是目标地址相对当前位置的偏移），不过由于全局符号介入的原因，这里不止使用相对地址跳转。见TODO(全局符号介入)