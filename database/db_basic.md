## 一、基本概念

### 1、视图

+ 作用：隐藏细节，保护数据。对视图的修改不影响基本表。
+ 查询的数据来源于不同的表，而查询者希望以统一的方式查询，可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。相比多表查询，视图使得我们获取数据更容易。
+ 不希望访问者获取整个表的信息，通过视图暴露部分字段给访问者。

### 2、键

+ 超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键
+ 候选键(candidate key):不含有多余属性的超键称为候选键
+ 主键(primary key):用户选作元组标识的一个候选键程序主键
+ 外键(foreign key)：如果关系模式R1中的某属性集不是R1的主键，而是另一个关系R2的主键则该属性集是关系模式R1的外键。

### 3、索引

+ 用来更加快速高效地查询数据。用户无法看到索引，它们只能被用来加速搜索/查询。
+ 更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。
+ 索引类型：
  + 唯一索引：唯一索引不允许两行具有相同的索引值。
  + 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空。
  + 聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个。范围查询。
  + 非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个。精确匹配。
+ 索引实现：B+ 树，位图，跳表。
+ 索引优缺点：
  + 优点：加速查询，分组、排序和连接都可加速。
  + 缺点：创建和维护的开销较大，索引需要占物理空间，增删改时需要动态维护。

### 4、事务和锁、ACID

+ 事务（Transaction）是并发控制的基本单位。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。
+ ACID
  + 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
  + 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
  + 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
  + 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。
+ 锁是实现事务的关键，锁可以保证事务的完整性和并发性。
  + 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。即当前事务将所有涉及操作的对象加锁，操作完成后释放给其它对象使用。
  + 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。即不同的事务可以同时看到同一对象（一般是数据行）的不同历史版本。如果有两个事务同时修改了同一数据行，那么在较晚的事务提交时进行冲突检测。

### 5、完整性约束

> 完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性，防止对数据的意外破坏。完整性约束通常被看作是数据库模式设计过程的一部分，作为用于创建关系的一部分被声明。

+ 实体完整性：关系的主关键字不能重复也不能取空值。
  + 实现：`PRIMARY KEY`
+ 参照完整性（Referential Integrity）：对于更新、插入或删除表间数据的完整性，统称为参照完整性。实现了表与表之间的联系，外键的取值必须是另一个表的主键的有效值，或是“空”值。
  + 实现：`foregin key() references tableName(filedName) [on delete|update casecade | no action]；`
+ 用户自定义完整性：保证数据库字段取值的合理性。包括限制类型(数据类型),格式(通过检查约束和规则),可能值范围(通过外键约束,检查约束,默认值定义,非空约束和规则)。
  + 实现：`(not null,unique,check短语)；`

### 6、存储过程

+ SQL语句在执行的时候需要要先编译，然后执行。而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字来调用它。

+ 存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。

+ 一个存储过程语句替代大量 SQL 语句 ，可以降低网络通信量，提高通信速率。

  ```sql
  mysql> CREATE PROCEDURE proc1(OUT s int)  // 这里有一个输出参数 s，类型是 int 型
      -> BEGIN 
      -> SELECT COUNT(*) INTO s FROM user;  
      -> END 
  ```

### 7、触发器

+ 触发器（trigger）是种特殊的存储过程，它是由事件来触发的。触发器的事件，是对表的增、删、改操作。当对一个数据库或表进行增、删、改（ Insert，Delete，Update）的时就会激活触发器。

### 8、范式

> 符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度。

+ 第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。**是所有关系型数据库的最基本要求**
+ 第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。
+ 第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y。

### 9、drop、delete和truncate

+ 不再需要一张表的时候，用 drop
+ 想删除部分数据行时候，用 delete，并且带上 where 子句
+ 保留表而删除所有数据的时候用 truncate

### 10、SQL常用命令

```sql
CREATE TABLE Student( 
ID NUMBER PRIMARY KEY, 
NAME VARCHAR2(50) NOT NULL); // 建表

CREATE VIEW view_name AS
Select * FROM Table_name; // 建视图 

Create UNIQUE INDEX index_name ON TableName(col_name); // 建索引

INSERT INTO tablename {column1,column2,…} values(exp1,exp2,…); // 插入

INSERT INTO Viewname {column1,column2,…} values(exp1,exp2,…); // 插入视图实际影响表

UPDATE tablename SET name='zang 3' condition; // 更新数据 

DELETE FROM Tablename WHERE condition; // 删除 

GRANT (Select,delete,…) ON (对象) TO USER_NAME [WITH GRANT OPTION]; // 授权 

REVOKE (权限表) ON(对象) FROM USER_NAME [WITH REVOKE OPTION] // 撤权
```

### 11、隔离级别

+ READ UNCOMMITED（未提交读）：事务中的修改，即使没有提交，对其它事务也都是可见的。可能发生`脏读`：即事务可以读取未提交的数据。（实际中很少使用）
+ READ COMMITTED（提交读）：满足事务隔离性的简单定义：一个事务开始时，只能看见已经提交的事务所做的修改。这个级别有时候也叫做`不可重复读`，因为它不保证事务重新读的时候能读到相同的数据，因为在每次数据读完之后其他事务可以修改刚才读到的数据。考虑下面这种情况：A事务读取一个数据项var=1，然后B事务更新该数据var=2并提交，A事务接着又重新读了该数据，结果var=2，第二次读到的数据和第一次的不相同。大多数数据库系统的默认隔离级别是 READ COMMITTED（但是MySQL不是）。
+ REPEATABLE READ（可重复读）：只允许读取已经提交的数据，而且`在一个事务两次读取一个数据项期间，其它事务不得更新该数据`。但该事务不要求和其它事务可串行化。可能存在`幻读`问题：当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。可重复读是 MySQL 的默认事务隔离级别。
+ SERIALIZABLE（可串行化）：最高的隔离级别，通过强制事务串行执行，避免前面的幻读问题。会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。
+ 隔离级别与避免的问题如下表所示：

| 隔离级别        | 脏读可能性 | 不可重复读可能性 | 幻读可能性 |
| --------------- | ---------- | ---------------- | ---------- |
| READ UNCOMMITED | ✔︎          | ✔︎                | ✔︎          |
| READ COMMITTED  | ✘          | ✔︎                | ✔︎          |
| REPEATABLE READ | ✘          | ✘                | ✔︎          |
| SERIALIZABLE    | ✘          | ✘                | ✘          |

+ [隔离级别和MVCC](http://ningg.top/inside-mysql-transaction-and-mvcc/)

### 12、DML和DDL

+ DML 部分包括删除、更新、插入、查询操作。
+ 数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。

### 13、性能优化

+ 建立索引
  + 应尽量避免在 where 子句中使用!=或<>操作符、对字段进行 null 值判断、使用 or 来连接条件，否则将引擎放弃使用索引而进行全表扫描。
+ 避免`select *`：从数据库里读出越多的数据，那么查询就会变得越慢。
+ 慢查询优化步骤：
  + 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
  + where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
  + explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
  + order by limit 形式的sql语句让排序的表优先查
  + 了解业务方使用场景
  + 加索引时参照建索引的几大原则
  + 观察结果，不符合预期继续从0分析

### 14、b+tree与btree

+ 一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关。
+ 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。
+ Innodb和MyISAM都使用B+Tree作为索引结构

### 15、FIT理论

+ 分布式系统的CAP理论已经是很老的理论，对于分布式数据库领域，最近学术界提出了FIT(fairness、strong isolation、throughput)
  + fairness：数据库系统对于每一个事务应该同等对待，立刻执行。不能因为某些原因阻塞某个事务一段时间
  + isolation：作者将isolation划分为strong isolation和weakness isolation，我的理解是strong isolation就是事务之间互不影响(好像只有可串行化)。
  + throughput：吞吐量
+ FIT只能满足其中两者：
  + 公平性和强隔离意味着要加锁，同时执行了分布式一致性协议，限制了吞吐量。代表性系统是spanner
  + 强隔离性和吞吐量同时满足，意味着需要一组冲突少或者没冲突的事务才能同时满足。需要等待这样的一组事务，这对某些事务不公平。代表性系统是voltdb
  + 公平性和吞吐量同时满足，那么肯定不能保证强隔离性。代表系统是普通的NOSQL

### 16、数据库架构设计

+ shared everything
  + 一般是针对单个主机，完全透明共享CPU/MEMORY/IO，并行处理能力是最差的，典型的代表SQLServer
+ Shared Disk
  + 各个处理单元使用自己的私有 CPU和Memory，共享磁盘系统。当存储器接口达到饱和的时候，增加节点并不能获得更高的性能 。
+ Shared Nothing
  + 各个处理单元都有自己私有的CPU/内存/硬盘等，不存在共享资源，类似于MPP（大规模并行处理）模式，各处理单元之间通过协议通信，并行处理和扩展能力更好。典型代表DB2 DPF和Hadoop ，各节点相互独立，各自处理自己的数据，处理后的结果可能向上层汇总或在节点间流转。
  + 我们常说的 **Sharding** 其实就是Share Nothing架构，它是把某个表从物理存储上被水平分割，并分配给多台服务器（或多个实例），每台服务器可以独立工作，具备共同的schema，比如MySQL Proxy和Google的各种架构，**只需增加服务器数就可以增加处理能力和容量**。

## 二、数据结构

### B树

![image](http://ww1.sinaimg.cn/large/77451733gy1g4yc5twyjzj20hc08caax.jpg)

+ B 树又叫平衡多路查找树，一棵 m 阶的 B 树：
  + 树中每个结点最多含有 m 个孩子（m >= 2）；
  + 除根结点和叶子结点外，其它每个结点至少有 [ceil(m / 2)] 个孩子（其中ceil(x)是一个取上限的函数）；
  + 根结点至少有 2 个孩子（除非 B 树只包含一个结点：根结点）；
  + 所有叶子结点都出现在同一层（叶子节点类似红黑树中，每一个 NULL 指针即当做叶子结点）。
+ B 树在插入数据时可能导致节点分裂，B 树在删除数据时可能导致节点间的数据迁移。
+ B 树中的每个结点根据实际情况可以包含大量的关键字信息和分支(当然是不能超过磁盘块的大小，根据磁盘驱动(disk drives)的不同，一般块的大小在 1k~4k 左右)；这样**树的深度降低了，IO 操作的次数也就减少了，而 IO 操作就是影响整个 B 树查找效率的决定因素**。因为查找一个元素只要很少结点从外存磁盘中读入内存，很快访问到要查找的数据。

### B+树

![](http://ww1.sinaimg.cn/large/77451733gy1g4ycc8symkj20ft09lq43.jpg)

+ 有 n 棵子树的结点中含有 n - 1 个关键字；
+ 指向存储数据的指针都只包含在叶子结点中，且叶子结点本身依关键字的大小自小而大的顺序链接。
+ 所有的非终端结点可以看成是索引部分（只包含索引信息，不包含数据信息），结点中仅含有其子树根结点中最大（或最小）关键字。

### B+ 树与 B 树的区别

+ B+ 树在**做索引**时的磁盘读写开销更低
  + B+-tree 的中间（非叶子）结点只有指向儿子节点的指针，没有指向具体存储数据的指针。其中间结点比 B 树更小，所以在索引时可以降低磁盘 IO 的开销。
+ B+ 树的**范围查询**效率更高
  + B 树没有解决元素遍历的效率低下的问题，因为要遍历一遍 B 树，需要对 B 树进行一次深度优先遍历，过程中每个中间节点都需要被读取多次。
  + B+ 树只要遍历叶子节点就可以实现整棵树的遍历，范围查询时不需要多次读取中间的索引节点，所以很好地支持了范围查询。
  + B+树查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
+ B 树索引更适合做内存中的索引，B+ 树索引更适合做磁盘上的索引
  + 如果不需要每次从磁盘中读出中间节点的话，显然 B 树更合适，因为 B 树不需要每次都查到叶子节点，可能在中间节点就查到要查找的数据了。

### 红黑树

![](http://ww1.sinaimg.cn/large/77451733gy1g4yctnq9xgj20m80apdgb.jpg)

+ 红黑树的5条性质：

  ```
  1）每个结点要么是红的，要么是黑的。  
  2）根结点是黑的。  
  3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
  4）如果一个结点是红的，那么它的俩个儿子都是黑的。  
  5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。
  ```

+ 红黑树多用在内部排序，即全放在内存中的，STL的map和set的内部实现就是红黑树。

+ B+树多用于外存上时，B+也被成为一个磁盘友好的数据结构。

+ B树多用在内存里放不下，大部分数据存储在外存上时。因为B树层数少，因此可以确保每次操作，读取磁盘的次数尽可能的少。

+ 在数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。反之，数据量较大，外存中占主要部分时，B树因其读磁盘次数少，而具有更快的速度。

+ 和`AVL`（自平衡二叉查找树）树的比较：

  + 如果插入一个 node 引起了树的不平衡，AVL 和 RB-Tree 都是最多只需要 2 次旋转操作，即两者都是 O(1)；但是在删除 node 引起树的不平衡时，最坏情况下，AVL 需要维护从被删 node 到 root 这条路径上所有 node 的平衡性，因此需要旋转的量级 O(logN)，而 RB-Tree 最多只需3次旋转，只需要 O(1) 的复杂度。
  + 其次，AVL 的结构相较 RB-Tree 来说更为平衡，在插入和删除 node 更容易引起 Tree 的 unbalance，因此在大量数据需要插入或者删除时，AVL 需要 rebalance 的频率会更高。因此，RB-Tree 在需要大量插入和删除 node 的场景下，效率更高。自然，由于 AVL 高度平衡，因此 AVL 的 search 效率更高。
  + map 的实现只是折衷了两者在 search、insert 以及 delete 下的效率。总体来说，RB-tree 的统计性能是高于 AVL 的。
  + 这里最大的差别在于旋转操作的次数。就插入和删除操作的复杂度来说，红黑树都可能会达到 O(logN)，但是红黑树的优点在于，旋转操作的次数是常数（有些插入和删除操作甚至不需要旋转，只要改变常数个节点的颜色）。**旋转操作的次数越少，意味着整棵树的拓扑结构不会频繁的做出大的改变。这一点是AVL树做不到的。**
  + 简单说就说红黑树维护开销小，AVL树查找效率高。

### B*树

![](http://ww1.sinaimg.cn/large/77451733gy1g4ycqy0kkcj20ft09l75j.jpg)

+ 是`B+`树的变体，在`B+`树的非根和非叶子结点再增加指向兄弟的指针；B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3（代替B+树的1/2）； 
+ `B+`树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针； 
+ `B*`树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针； 
  所以，`B*`树分配新结点的概率比`B+`树要低，空间使用率更高； 

### Bloom过滤器

+ 在很多场景下，我们都需要一个能迅速判断一个元素是否在一个集合中。
  + 网页爬虫对URL的去重，避免爬取相同的URL地址；
  + 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）；
  + **缓存击穿**，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。
    + 查询一个在缓存内必然不存在的数据，导致每次请求都要去存储层去查询，这样缓存就失去了意义。如果在大流量下数据库可能挂掉。缓存击穿是黑客攻击系统的常用手段。
+ 一个元素被加入集合时，通过K个hash函数（散列函数）把这个元素映射成一个位图m里的K个点，把它们置为1。
+ 检索时，就用相同的K个hash函数对被检索的元素也映射成K个点，如果这些点有任何一个为0，则被检索元素一定不在集合里；如果都是1，被检索元素很可能在集合里，但实际上都是1也不一定在集合里，会有一定的误判概率。
+ 所以布隆过滤器是在真正的 hash_map 过滤前的一次低成本过滤。
+ m数组的长度：`m = -(n/ln(p)) / (ln2)^2`，p为误判率
+ hash函数的个数：`k= (ln2)*(m/n)`
+ 布隆过滤器会有误报，对已经发现的误报样本可以通过建立白名单来防止误报。

### 跳表

![](http://ww1.sinaimg.cn/large/77451733gy1g4yhgjxqfjj20sl06baa1.jpg)

+ 跳表就是维护了一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。
+ 其效率可比拟于二叉查找树（对于大多数操作需要`O(log n)`平均时间）。
+ 基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表，因此得名。所有操作都以对数随机化的时间进行。

### 字典(Trie)树

![image](https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/400px-Trie_example.svg.png)

+ 二叉查找树保存的是键，一个键保存在一个节点中。
+ 而字典树保存的是字符串前缀，一个前缀保存在"一条路径"上。一个节点的所有子孙都有相同的前缀，而根节点对应空字符串。
+ 典型应用是用于统计和排序大量的字符串，所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。（感觉仅次于 hash 表）
+ trie 树常用于**搜索提示**。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。
+ 核心思想就是空间换时间。字典树的查询效率很高；但由于稀疏现象严重，导致空间利用效率很低。
