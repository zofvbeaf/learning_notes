## Course

+ [ustc network](<http://staff.ustc.edu.cn/~billzeng/network/network.htm>)
+ [cmu 15744](<http://www.cs.cmu.edu/~15744/syllabus.html>)

## 问题

+ 四层、五层和OSI七层协议
+ `IEEE802.3`帧的数据长度最短是38字节，最长是1492字节，而以太网数据帧的长度最短是46字节，最长是1500字节。
  + 以太网更常用
+ `ARP`在`TCP/IP`模型中属于网络层协议，在OSI模型中属于链路层协议。
+ 主机字节序为小端，低位在低地址，网络字节序为大端。

## TCP

![1562895233092](http://ww1.sinaimg.cn/large/77451733gy1g4wsynav0pj20mt0iijvs.jpg)

### TCP头部

![](http://ww1.sinaimg.cn/large/77451733gy1g4voj9r2huj21bm0hsgp6.jpg)

+ TCP头部最小为20字节，最大为60字节，因为选项字段最长为40字节。

  + `data offset`：首部长度
  + `ACK`：确认，使得确认号有效。
  + `PSH`：提示接收端，从TCP接收缓冲区中读走数据 
  + `RST`：重置连接（经常看到的`reset by peer`）就是此字段搞的鬼。
  + `SYN`：用于初始化一个连接的序列号。 
  + `FIN`：该报文段的发送方已经结束向对方发送数据。
  + 当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。
  + `window size`：窗口大小，表示想收到的TCP数据段的大小
  + `checksum`：校验和：发送端填充，用`CRC`算法。

+ TCP选项字段

  ![](http://ww1.sinaimg.cn/large/77451733gy1g4vq025j8zj20e308gwfq.jpg)

  + Kind=0 选项表结束选项 

  + Kind=1 空操作选项 

  + Kind=2 最大报文段长度选项 

  + Kind=3 窗口扩大因子选项 TCP连接初始化时，通讯双方使用该选项来协商接受通告窗口的扩大因子 只能出现在同步报文段中 

  + **Kind=4选择确认选项（SACK）** TCP通信中，某个报文段丢失，TCP模块会重发最后确认的TCP报文段的后续所有报文段，这可能导致重复，SACK技术直接发送丢失的报文段就好。**（默认打开）**，不需要两边都打开才生效

  + Kind=5 SACK实际工作选项 该选项参数告诉发送方本端已经收到并缓存不连续的数据块，发送端根据此选项检查并重发丢失的数据块 

  + **Kind=8 时间戳选项** 比较准确的计算通讯双方的回路时间的方法,**（默认打开）**，需要两边都打开才生效

    ```
    Kind: 8             // 标记唯一的选项类型，比如window scale是3
    Length: 10 bytes    // 标记Timestamps选项的字节数
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    | Kind=8 | Length=10 | TS Value (TSval) | TS ECho Reply (TSecr) |
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        1          1             4                       4
    ```

+ `TCP`和`UDP`区别

  + `TCP`面向连接，可靠，字节流，传输慢，首部开销`20`字节较大，点对点
  + `UDP`无连接，不可靠（尽最大努力交付），面向报文（不拆分直接给IP层），传输快，首部`8`字节，不做流量控制和拥塞控制，支持广播和多播

+ `HTTP`基于`TCP`，虽然`UDP`适合用来传输实时视频流，但是主流的解决方案还是采用`HTTP`

+ TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

+ TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复

### TCP三次握手

![](http://ww1.sinaimg.cn/large/77451733gy1g4vor9bzk8j20ra0e9n07.jpg)

+ 三次握手的目的

  + 连接服务器指定端口，建立 TCP 连接，并同步连接双方的`ISN(Initial Sequence`
    `Number)`，以便让对方知道接下来接收数据的时候如何按序列号组装数据

    + `ISN = M + F(localhost, localport, remotehost, remoteport)`
    + M是一个计时器，每隔4毫秒加1。 F是一个Hash算法

    + 序列号回绕：因为ISN是随机的，所以序列号容易就会超过`2^31-1`. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的TCP序列号回绕。

      ```c
      /*
      * The next routines deal with comparing 32 bit unsigned ints
      * and worry about wraparound (automatic with unsigned arithmetic).
      */
      static inline int before(__u32 seq1, __u32 seq2)
      {
          return (__s32)(seq1-seq2) < 0;
      }
      
      #define after(seq2, seq1) before(seq1, seq2)
      /******
      假设seq1=255， seq2=1（发生了回绕）。
      seq1 = 1111 1111 seq2 = 0000 0001
      我们希望比较结果是
       seq1 - seq2=
       1111 1111
      -0000 0001
      -----------
       1111 1110
      由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数,即是before的关系
      ****/
      ```

  + 交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 `connect()` 时。将触发三次握手。

  + 确认双方的收发能力正常。
  
  + `listen`队列是半连接队列，`accept`队列是完全连接队列
  
  + `keepalive`机制：默认两小时没有数据交换后开始每隔`75`秒发一个`keepalive_prob`报文探测，最多发9个仍没有响应则返回`ETIMEOUT`并关闭连接

### TCP四次挥手

![](http://ww1.sinaimg.cn/large/77451733gy1g4vp3b0sdbj20qw0g4dit.jpg)

+ `FIN_WAIT_2`有一 个超时时间，`/proc/sys/net/ipv4/tcp_fin_timeout`为`60`秒

+ 当TCP执行一个主动关闭，并发回最后一个ACK,该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN)。

+ 存在这个规则导致一个后果就是在这个2MSL的时间内，该地址上的链接（客户端地址、端口和服务器端的地址、端口）不能被使用。

  + `MSL(Maximum Segment Lifetime)`：这是一个IP数据包能在互联网上生存的最长时间，超过这个时间IP数据包将在网络中消失 。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒。

+ 大量`TIME_WAIT`的解决办法：

  + `vim /etc/sysctl.conf`，

    + 令`net.ipv4.tcp_tw_reuse = 1`示开启允许将`TIME-WAIT sockets`重新用于新的TCP连接，默认为0，表示关闭；开启后客户端在1s内回收。
      + 通过`timestamp`的递增性来区分是否新连接，新连接的`timestamp`更大，那么保证小的`timestamp`的 `fin` 不会fin掉新连接，不用等`2MSL`。
    + `net.ipv4.tcp_tw_recycle = 1` 表示开启TCP连接中`TIME-WAIT sockets`的快速回收，默认为0，表示关闭。对客户端和服务器同时起作用，开启后在 3.5*RTO 内回收，RTO 200ms~ 120s 具体时间视网络状况。

    ```bash
    [root@database41 ~]# sysctl -a | grep time | grep wait
    ...
    net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60
    net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120
    net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120
    ```

    + 通过`tcp_max_tw_buckets = 262144`配置最大上限
    + 利用`SO_LINGER`选项的强制关闭方式，发RST而不是FIN，来越过TIMEWAIT状态，直接进入CLOSED状态。

### SYN FLOOD攻击

+ 问题：
  + 如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block：存储了每一个连接中的一些重要信息：TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号等等）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被响应。
  + 当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。
+ 解决办法：
  + 无效连接的监视释放
    + 监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。
  + 延缓TCB分配方法
    + 消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。
      + **Syn Cache**技术：系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。
      + **Syn Cookie**技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。
        + `/proc/sys/net/ipv4/tcp_syncookies`：内核默认开启了此选项
        + MSS(Maximum Segment Size)，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。当双方在都在一个本地**以太网上时规定MSS为1460**(1460+20(TCP首部)+20(IP首部))))
    + 使用SYN Proxy
      + 防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。
    + 连接队列
      + 维护处于SYN_RCVD状态的半连接队列和处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。
      + `net.ipv4.tcp_max_syn_backlog = 8192` 表示SYN队列的长度，默认为1024，可增大。
    + 也可缩短SYN超时时间

### 套接字选项

+ `SO_LINGER`：设置函数close()关闭TCP连接时的行为。缺省close()的行为是，如果有数据残留在socket发送缓冲区中则系统将继续发送这些数据给对方，等待被确认，然后返回。
  + 利用此选项，可以将此缺省行为设置为以下两种：
    + 立即关闭该连接，通过发送`RST`分组(而不是用正常的`FIN|ACK|FIN|ACK`四个分组)来关闭该连接。至于发送缓冲区中如果有未发送完的数据，则丢弃。主动关闭一方的TCP状态则跳过TIMEWAIT，直接进入CLOSED。`l_onoff`非0，`l_linger`为0。
    + 将连接的关闭设置一个超时。如果socket发送缓冲区中仍残留数据，进程进入睡眠，内核进入定时状态去尽量去发送这些数据。`l_onoff`和`l_linger`均非0。

### RST产生的几种情况

+ 目标端口未监听
+ 目的主机或者网络路径中防火墙拦截
+ `socket`接收缓冲取`Recv-Q`中的数据未完全被应用程序读取时关闭该`socket`
+ 向已关闭的`socket`发送数据
+ 向已关闭的连接发送`FIN`
+ 向已经消逝的连接中发送数据
+ 对已经收到`rst`的连接进行`io`操作会产生`SIGPIPE`信号。

### TCP滑动窗口

> 现在内核的初始拥塞控制窗口为10(即10个MSS大小，15k)。
>
> 可以按如下方式配置
>
> ```
> sudo ip route change default via 192.168.1.1 dev eth0  proto static initcwnd 10
> ```

![](http://ww1.sinaimg.cn/large/77451733gy1g56jofs08fj20qp0hv0xu.jpg)

![](https://ws1.sinaimg.cn/large/77451733gy1g56jow5jj9j20qe0g3n0s.jpg)

+ 根据B给出的窗口值，A构造出自己的发送窗口。

+ 发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。

+ 发送窗口里面的序号表示允许发送的序号。

+ 显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。

+ A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）

+ TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。

+ TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。

+ 假设**已发送未确认（第二类）**字节（34-45）分为4个segment传输，34-35，36-37，38-41，42-45，第1,2,4已经到达，第3段没有到达。此时发送方只会收到ack=38。等到TCP重传机制触发，重新发送数据（可能不仅发38-41,42-45也会被重发，因为TCP不会对每一个片段分别确认。）

+ **数据被服务器确认了，并不意味着已经从缓冲区取走了。**当服务器的接收速率 > 处理速率，会把缓冲区填满。此时需要增加或缩小窗口大小，让服务器和客户端能够确保对端发送数据的速度等同于处理速度。

  + 假设我们接收到140字节，但只能发送40字节给应用程序，缓存中剩下100字节。当发送140字节的确认信息，服务器将发送窗口缩小100字节，至260字节。当客户端从服务器接收到这一片段，它将会看到140字节的确认信息并将窗口向右滑动140字节。在滑动过程中，将大小缩减至260字节。可以认为将窗口左端滑动140字节，但右端仅滑动40字节。新的稍小一些的窗口保证服务器从客户端接收最多260字节数据，以适应接收缓存中的剩余空间.

    ![](http://ww1.sinaimg.cn/large/77451733gy1g4w1hmqcq3j20ce0fhdhf.jpg)

+ 可能发生死锁：
  + B向A发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是B向A发送了 rwnd = 400 的报文段。
  + 但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。
  + 如果没有其他措施，这种互相等待的死锁局面将一直延续下去。
  + 为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。
  + 只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。
  + 若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。
  + 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。
  + 若窗口不是零，则死锁的僵局就可以打破了。

### TCP重传机制

+ TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。

  + 包含数据的片段一经发送，片段的一份副本就放在名为**重传队列**的数据结构中，此时**启动重传计时器**。因此，在某些时间点，每一个片段都会放在队列里。队列按照重传计时器的剩余时间来排列，因此TCP软件可追踪那几个计时器在最短时间内超时。
  + 如果在计时器超时之前收到了确认信息，则该片段从重传队列中移除。超时重传之后的片段依旧保留在重传队列。重启计时器再失败、再重复（不会一直重传）。

+ TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。

  ![1562834012363](http://ww1.sinaimg.cn/large/77451733gy1g4vzh2cjarj20ol0dodjv.jpg)

  ![1562834064947](http://ww1.sinaimg.cn/large/77451733gy1g4vzhxyogfj20ol0gcq6r.jpg)

  ![1562834993789](https://ws1.sinaimg.cn/large/77451733gy1g56jplgvosj20nq0dvgqo.jpg)

  ![1562835009865](https://ws1.sinaimg.cn/large/77451733gy1g56jpz2vdtj20o80fpn0j.jpg)

### TCP确认机制

+ 累计确认
  + 缺点：
    + 假设第一个丢失了，后面的即使被接收方收到了，也无法返回ack。
  + 解决方法：
    + 重传超时的片段：最坏情况下，所有20个片段都丢失了。我们需要等片段1超时并重传。这一片段也许会得到确认，但之后我们需要等待片段2超时并重传。这一过程会重复多次。
    + 重传所有片段：很多重传是不必要的。如果第一个片段丢失而其他19个实际上接收到了，则浪费网络资源
    + **选择确认：**解决方式是对TCP滑动窗口算法进行扩展，添加允许设备**分别确认非连续片段**的功能。
      + 连接时使用的SYN片段来协商是否允许SACK。SACK选项。这一选项包含一个关于已接收但未确认片段数据`sequence number`范围的列表，由于它们是非连续的。各设备对重传队列进行修改，如果该片段已被选择确认过，则该片段中的SACK比特位置为1。一个片段重传之后，之后所有片段也会重传，除非`SACK`比特位为1。
      + `cat /proc/sys/net/ipv4/tcp_sack`为`1`，`linux`下，`sack`选项是默认开启的，[参考地址](https://wuguiyunwei.com/index.php/2010/11/06/1202.html)
      + 由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明4个**已接收**的字节块的边界信息（因为需要指明左右边界）。`kind`和`length`各占一个字节。
+ 延迟确认机制：
  + 接收方在收到数据后，并不会立即回复`ACK`,而是延迟一定时间。一般`ACK`延迟发送的时间为`200ms`，但这个`200ms`并非收到数据后需要延迟的时间。系统有一个固定的定时器每隔`200ms`会来检查是否需要发送`ACK`包。这样做有两个目的。
  + 这样做的目的是`ACK`是可以合并的，也就是指如果连续收到两个`TCP`包，并不一定需要`ACK`两次，只要回复最终的`ACK`就可以了，可以降低网络流量。
  + 如果接收方有数据要发送，那么就会在发送数据的`TCP`数据包里，带上`ACK`信息。这样做，可以避免大量的`ACK`以一个单独的`TCP`包发送，减少了网络流量。

### 传输效率考虑

+ 可以用不同的机制来控制 TCP 报文段的发送时机:
  + 第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。
  + 第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push)操作。
  + 第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。
  + 如何控制 TCP 发送报文段的时机仍然是一个较为复杂的问题。
+ 发送方糊涂窗口综合症：
  + 发送方 TCP 每次接收到一字节的数据后就发送。 这样，发送一个字节需要形成 41 字节长的 IP 数据报。若接收方确认，并回送这一字节，就需传送总长度为 162 字节共 4 个报文段。效率很低。
  + **解决方法**：使用 `Nagle` 算法。
    + tcp默认开启，可通过`setsockopt`来
    + 若发送应用进程把要发送的数据逐个字节地送到`TCP`的发送缓存，则发送方就把第一个数据字节先发送去，把后面到达的数据字节都缓存起来。
    + 当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。
    + 只有在收到对前一个报文段的确认后才继续发送下一个报文段。
    + 当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。
  + 当接收方的 TCP 缓冲区已满，接收方会向发送方发送窗口大小为 0 的报文。若此时接收方的应用进程以交互方式每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是41 字节长），于是接收窗口又满了，如此循环往复。
  + **解决方法**：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。

### TCP拥塞控制

> 内核实现采用的是[cubic](http://www.voidcn.com/article/p-fizolans-ok.html)算法，拥塞窗口默认初始是10.`net/ipv4/tcp.c:427`
>
> `tp->snd_cwnd = TCP_INIT_CWND;`

![](http://ww1.sinaimg.cn/large/77451733gy1g4w62brzk0j20h908pwff.jpg)

- 当 `cwnd < ssthresh` 时，使用上述的慢开始算法。

- 当 `cwnd > ssthresh` 时，停止使用慢开始算法而改用拥塞避免算法。

- 当 `cwnd = ssthresh` 时，既可使用慢开始算法，也可使用拥塞控制避免算法。

- 拥塞控制与流量控制的区别：
  - 拥塞控制：TCP模块为了防止过多的数据注入网络，**使网络中的路由器或链路不致于过载**，以此提高网络利用率。拥塞问题是一个全局性的问题,涉及到所有的主机、所有的路由器、以及与降低网络传输性能有关的所有因素。
  - **流量控制：**流量控制往往指的是**点对点**通信量的控制，是个**端到端的**问题。流量控制所要做的就是控制**发送端**发送数据的速率，以便使**接收端**来得及接受。

- 发送端向网络一次连续写入的数据量，我们称为`SWND`（Send Window**，发送窗口**）

- 发送端需要合理的选择`SWND`的大小，如果`SWND`太小，会引起明显的网络延迟；反之，如果SWND太大，则容易导致网络拥塞。所以还需要引入一个称为**拥塞窗口**（`Congestion Window,CWND`）的状态变量

- 发送方维持一个拥塞窗口`CWND`的状态变量。它的大小取决于网络的拥塞程度，并且在动态的变化，发送方会让自己的发送窗口等于这个拥塞窗口。

- 如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞。

- 发送方控制拥塞窗口的原则是： 

  - 只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。 
  - 但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

- 慢启动：

  - 慢开始的"慢"并不是指`cwnd`的增长速率慢，而是指在`TCP`开始发送报文段时先设置`cwnd=1`，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大`cwnd`。

- 拥塞避免：

  - 让拥塞窗口`cwnd`缓慢地增大，即每经过一个往返时间`RTT`就把发送方的拥塞窗口`cwnd`加1，而不是加倍。这样拥塞窗口`cwnd`按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

- 只要发送方**判断出网络拥塞**，不论是在慢开始还是拥塞控制阶段，都要把慢开始门限值设置为出现拥塞时发送端窗口大小的一半，但不能小于2。然后把`cwnd`重新置为1，执行慢开始算法。 

  - 门限值减半，`cwnd`重置为1，目的是减少发送到网络中的分组数，使得发生拥塞的路由器能够有时间能把队列中积压的分组处理掉。 

- 发送端判断网络拥塞的依据： 

  - 传送超时，即TCP重传定时器溢出 
  - 收到重复的确认报文

- **快重传**算法要求接收方每收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。发送方只要一连**收到3个同样的确认报文**就应当立即重传数据报，不必等待报文段的重传计时器到期。

  - `net.ipv4.tcp_fack = 1`：默认打开FACK(Forward ACK) **拥塞避免**和 **快速重传**功能。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)

- **快回复**：把慢开始门限减半，“乘法减小”，将`cwnd`设置为新的慢开始门限值，继续执行拥塞避免算法，“加法增大”。(AIMD)

  - `cwnd = cwnd/2, sshthresh = cwnd ` 

  - **待考据：**

    > 内核中默认`/proc/sys/net/ipv4/tcp_max_ssthresh 为 0`，这个值表示慢启动阈值。如果拥塞窗口的值`cwnd`小于阈值`ssthresh`，那么表示在慢启动阶段；如果拥塞窗口的值`cwnd`大于阈值`ssthresh`，那么表示在拥塞避免阶段，此时拥塞窗口`cwnd`不再像慢启动阶段那样呈指数级整整，而是趋向于线性增长，以期避免网络拥塞。默认情况下，拥塞窗口会一直处于线性增长阶段，即增长非常慢。一旦出现丢包，拥塞窗口的值会减半。即在连接建立初期以及出现丢包后，拥塞窗口的值都会较小。从而使得传送的数据可能需要多次分块传输。

+ 发送方的发送窗口的上限值应当取为接收方窗口 `rwnd` 和拥塞窗口 `cwnd` 这两个变量中较小的一个

### [TCP粘包、拆包](https://www.v2ex.com/t/478610?p=2)

+ 产生原因：
  + 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
  + 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
  + 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文长度-TCP 头部长度>MSS 的时候将发生拆包。
  + 接收方法不及时读取套接字缓冲区数据，这将发生粘包。
+ 解决办法：
  + 使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。
  + 设置定长消息，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。
  + 设置消息边界，服务端从网络流中按消息编辑分离出消息内容，一般使用‘\n ’。

## IP

### 地址类型

```
A: 0                     对应子网掩码：255.0.0.0(8位)
B: 10                    对应子网掩码：255.255.0.0（16位）
C: 110                   对应子网掩码：255.255.255.0（24位）	
D: 1110  用于多播
E: 11110
全零（0．0．0．0）地址对应于当前主机。全1的IP地址（255．255．255．255）是当前子网的广播地址。
```

### ICMP

+ `DESTINATION UNREACHABLE`：消息用于当路由器无法找到目标地址
+ `TIME EXCEEDED`：消息是由于报文TTL（Time to live）计数器到达时。该事件是报文在回环，或计数器值设置过低的迹象。

### traceroute

+ traceroute发现从主机到目的IP地址路径上的路由器。它向目的地发送IP包，第一次的时候，将TTL设置为1，引发第一个路由器的`Time Exceeded`错误。这样，第一个路由器回复ICMP包，从而让出发主机知道途径的第一个路由器的信息。随后TTL被设置为2、3、4，...，直到到达目的主机。这样，沿途的每个路由器都会向出发主机发送ICMP包来汇报错误。traceroute将ICMP包的信息打印在屏幕上，就是接力路径的信息了。这并不是TIME EXCEEDED信息的本意，但却是非常有用的故障排查工具。

### [NAT](https://blog.csdn.net/hzhsan/article/details/45038265)

![](http://ww1.sinaimg.cn/large/77451733gy1g4wugyhbxcj20ht0e43yh.jpg)

+ 作用：
  + 私有地址->共有地址
  + 屏蔽网络内部的地址
+ 分类：
  + 静态NAT：此类NAT在本地和全局地址之间做一到一的永久映射。须注意静态NAT要求用户对每一台主机都有一个真实的Internet IP地址。
  + 动态NAT：允许用户将一个未登记的IP地址映射到一个登记的IP地址池中的一个。采用动态分配的方法将外部合法地址映射到内部网络，无需像静态NAT那样，通过对路由器进行静态配置来将内部地址映射到外部地址，但是必须有足够的真正的IP地址来进行收发包。
  + 端口NAT（PAT）：最为流行的NAT配置类型。通过多个源端口，将多个未登记的IP地址映射到一个合法IP地址（多到一）。使用PAT能够使上千个用户仅使用一个全局IP地址连接到`Internet`。

## 参考

+ [UDP 和 TCP 的 socket 分别一般用在什么地方？](https://www.zhihu.com/question/20060141)
+ [用户态TCP/IP协议栈](https://blog.csdn.net/Solstice/article/details/26363901)
+ `c10k`和 `c10m`问题
